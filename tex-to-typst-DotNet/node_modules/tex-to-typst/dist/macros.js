function isEmptyNode(node) {
    if (!(node === null || node === void 0 ? void 0 : node.content) || node.content.length === 0)
        return true;
    return false;
}
export const typstStrings = {
    ',': (state) => state.data.inFunction && state._currentFunctions.slice(-1)[0] !== 'text'
        ? 'comma'
        : ',',
    '&': (state) => (state.data.inArray ? ',' : '&'),
    '/': '\\/',
    ';': '\\;',
    '~': 'med',
    '"': '\\"',
};
const brackets = {
    '[': 'bracket.l',
    ']': 'bracket.r',
    '{': 'brace.l',
    '}': 'brace.r',
    '(': 'paren.l',
    ')': 'paren.r',
    '|': 'bar.v',
};
function createBrackets(scale) {
    return (state, node) => {
        var _a;
        const args = node.args;
        node.args = [];
        const b = ((_a = args === null || args === void 0 ? void 0 : args[0].content) === null || _a === void 0 ? void 0 : _a[0]).content;
        const typstB = brackets[b];
        if (!typstB)
            throw new Error(`Undefined left bracket: ${b}`);
        return `#scale(x: ${scale}, y: ${scale})[$ ${typstB} $]`;
    };
}
function splitStrings(node) {
    var _a, _b, _c;
    if (((_b = (_a = node.args) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.length) === 1 &&
        ((_c = node.args) === null || _c === void 0 ? void 0 : _c[0].content)[0].type === 'string') {
        node.args[0].content = node.args[0].content[0].content
            .split('')
            .map((l) => ({ type: 'string', content: l }));
    }
}
export const typstMacros = {
    $: '\\$',
    cdot: 'dot.op',
    to: 'arrow.r',
    rightarrow: 'arrow.r',
    Rightarrow: 'arrow.r.double',
    leftarrow: 'arrow.l',
    Leftarrow: 'arrow.l.double',
    leftrightarrow: 'arrow.l.r',
    gets: 'arrow.l',
    rightharpoonup: 'harpoon.rt',
    rightharpoondown: 'harpoon.rb',
    leftharpoonup: 'harpoon.lt',
    leftharpoondown: 'harpoon.lb',
    infin: 'infinity', // This is a mathjax only thing, https://docs.mathjax.org/en/v2.7-latest/tex.html#i
    infty: 'infinity', // oo
    nonumber: '',
    int: 'integral',
    iint: 'integral.double',
    sqrt: (state, node) => {
        var _a;
        if (isEmptyNode((_a = node.args) === null || _a === void 0 ? void 0 : _a[0]))
            return 'sqrt';
        return 'root';
    },
    vec: 'arrow',
    mathbf: 'bold',
    boldsymbol: 'bold',
    mathrm: 'upright',
    textrm: 'upright',
    rm: 'upright',
    mathcal: 'cal',
    mathfrak: 'frak',
    pm: 'plus.minus',
    partial: 'diff',
    _: (state, node) => {
        splitStrings(node);
        return '_';
    },
    '^': (state, node) => {
        splitStrings(node);
        return '^';
    },
    bigl: createBrackets('120%'),
    bigr: createBrackets('120%'),
    big: createBrackets('120%'),
    Bigl: createBrackets('180%'),
    Bigr: createBrackets('180%'),
    Big: createBrackets('180%'),
    left: (state, node) => {
        var _a;
        const args = node.args;
        node.args = [];
        const left = ((_a = args === null || args === void 0 ? void 0 : args[0].content) === null || _a === void 0 ? void 0 : _a[0]).content;
        if (left === '(')
            return '(';
        if (left === '[')
            return '[';
        if (left === '{')
            return '{';
        if (left === '|')
            return '|';
        if (left === '.')
            return '';
        if (left === 'lbrack')
            return '[';
        throw new Error(`Undefined left bracket: ${left}`);
    },
    lbrack: '[',
    right: (state, node) => {
        var _a;
        const args = node.args;
        node.args = [];
        const right = ((_a = args === null || args === void 0 ? void 0 : args[0].content) === null || _a === void 0 ? void 0 : _a[0]).content;
        if (right === ')')
            return ')';
        if (right === ']')
            return ']';
        if (right === '}')
            return '}';
        if (right === '|')
            return '|';
        if (right === '.')
            return '';
        if (right === 'rbrack')
            return ']';
        throw new Error(`Undefined right bracket: ${right}`);
    },
    rbrack: ']',
    operatorname: (state, node) => {
        var _a;
        const text = (_a = node.args) === null || _a === void 0 ? void 0 : _a.slice(-1)[0];
        node.args = [{ type: 'macro', content: 'text', args: [text] }];
        return 'op';
    },
    mathop: 'op',
    '\\': (state, node) => {
        var _a;
        node.args = [];
        if (state.data.inArray) {
            state.data.previousMatRows = ((_a = state.data.previousMatRows) !== null && _a !== void 0 ? _a : 0) + 1;
            if (state._value.slice(-1) === ']')
                state.addWhitespace();
            return ';';
        }
        return '\\\n';
    },
    cr: (state, node) => {
        var _a;
        node.args = [];
        if (state.data.inArray) {
            state.data.previousMatRows = ((_a = state.data.previousMatRows) !== null && _a !== void 0 ? _a : 0) + 1;
            if (state._value.slice(-1) === ']')
                state.addWhitespace();
            return ';';
        }
        return '\\\n';
    },
    sim: 'tilde',
    cong: 'tilde.equiv',
    simeq: 'tilde.eq',
    ne: '!=',
    phi: 'phi.alt',
    varphi: 'phi.alt',
    varepsilon: 'epsilon',
    propto: 'prop',
    doteq: 'dot(eq)',
    ge: 'gt.eq',
    geq: 'gt.eq',
    gg: 'gt.double',
    le: 'lt.eq',
    leq: 'lt.eq',
    ll: 'lt.double',
    neq: 'eq.not',
    otimes: 'times.circle',
    circ: 'compose',
    vert: 'bar.v',
    dot: 'dot',
    ddot: 'dot.double',
    dots: 'dots.h',
    ldots: 'dots.h',
    vdots: 'dots.v',
    ddots: 'dots.down',
    subseteq: 'subset.eq',
    cdots: 'dots.h.c',
    cap: 'sect',
    cup: 'union',
    widehat: 'hat',
    // Spaces
    ',': 'thin',
    ':': 'med',
    ';': 'thick',
    '!': '#h(-1em)',
    quad: 'quad',
    qquad: 'wide',
    prod: 'product',
    lfloor: 'floor.l',
    rfloor: 'floor.r',
    implies: 'arrow.r.double.long',
    biggl: '',
    biggr: '',
    ' ': '" "',
    mathbb: (state, node) => {
        var _a, _b, _c, _d, _e;
        const text = (_e = (_d = (_c = (_b = (_a = node.args) === null || _a === void 0 ? void 0 : _a.slice(-1)[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.content) !== null && _e !== void 0 ? _e : '';
        const letters = text
            .split('')
            .map((l) => `${l}${l}`)
            .join(' ');
        node.args = [];
        return letters;
    },
    mathscr: (state) => {
        state.useMacro(`#let scr(it) = text(features: ("ss01",), box($cal(it)$))`);
        return 'scr';
    },
    overset: (state, node) => {
        var _a;
        state.useMacro('#import "@preview/ouset:0.2.0": *');
        node.args = (_a = node.args) === null || _a === void 0 ? void 0 : _a.reverse();
        return 'overset';
    },
    underset: (state, node) => {
        var _a;
        state.useMacro('#import "@preview/ouset:0.2.0": *');
        node.args = (_a = node.args) === null || _a === void 0 ? void 0 : _a.reverse();
        return 'underset';
    },
    overrightarrow: (state, node) => {
        var _a;
        (_a = node.args) === null || _a === void 0 ? void 0 : _a.push({ type: 'argument', content: [{ type: 'macro', content: 'arrow' }] });
        return 'accent';
    },
    overleftarrow: (state, node) => {
        var _a;
        (_a = node.args) === null || _a === void 0 ? void 0 : _a.push({ type: 'argument', content: [{ type: 'macro', content: 'arrow.l' }] });
        return 'accent';
    },
    middle: (state) => {
        var _a;
        return `mat(delim: #("|", none), ${';'.repeat((_a = state.data.previousMatRows) !== null && _a !== void 0 ? _a : 1)})`;
    },
    stackrel: (state, node) => {
        var _a;
        const args = (_a = node.args) === null || _a === void 0 ? void 0 : _a.reverse();
        node.args = [];
        state.writeChildren(args === null || args === void 0 ? void 0 : args[0]);
        state.write('^');
        state.writeChildren(args === null || args === void 0 ? void 0 : args[1]);
        return '';
    },
    color: (state, node) => {
        var _a, _b, _c;
        const [fill, children] = (_a = node.args) !== null && _a !== void 0 ? _a : [];
        const color = (_c = (_b = fill.content) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.content;
        node.args = [];
        state.openFunction(`#text(fill: ${color})`, { openToken: '[$ ', closeToken: ' $]' });
        state.writeChildren(children);
        state.closeFunction();
        return '';
    },
};
const matrixEnv = (delim) => (state, node) => {
    state.data.inArray = true;
    state.data.previousMatRows = 0;
    state.openFunction('mat');
    state.write(`delim: ${delim ? `"${delim}"` : '#none'},`);
    state.writeChildren(node);
    state.closeFunction();
    state.data.inArray = false;
};
export const typstEnvs = {
    array: matrixEnv(),
    matrix: matrixEnv(),
    pmatrix: matrixEnv('('),
    bmatrix: matrixEnv('['),
    Bmatrix: matrixEnv('{'),
    vmatrix: matrixEnv('|'),
};
